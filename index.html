<html>
	<head>
		<meta charset="utf-8" />
		<title> Labyrint</title>
		<link rel="stylesheet" type="text/css" href="style.css">

		<script src="visualizer.js" type="text/javascript"></script>
		<script src="js/two.min.js"></script>
		<script src="js/pitch.js"></script>
	</head>
	
	<body>
		<header>
			<link href='http://fonts.googleapis.com/css?family=Lobster' rel='stylesheet' type='text/css'>


			<div class="wrapper">
				<div class="game">
					<h1>Labyrint</h1>
					<span id="pitch">--</span>Hz</div>

				</div>	
				<canvas class="visualizer"></canvas>
			</div>

		</header>			


		<script>

			window.navigator = window.navigator || {};

     		navigator.getUserMedia = navigator.getUserMedia       ||
                               navigator.webkitGetUserMedia ||
                               navigator.mozGetUserMedia    ||
                               null;


            //Initierar ljudkontexten tillsammans med egenskaperna för analysen
			var context = new (window.AudioContext || window.webkitAudioContext)();
			var analyser = context.createAnalyser();
			analyser.fftSize = 2048;
			var bufferLength = analyser.frequencyBinCount; // half the FFT value
			bufferLength = bufferLength/15;
				var freqDomain = new Uint8Array(bufferLength); // create an array to store the data
			
			//Tar in mikrofonljud, samt ritar om intagandet går bra.
			navigator.getUserMedia({audio: true}, function(stream) {
				
				var source = context.createMediaStreamSource(stream);
				
				source.connect(analyser);
				
				//Updatera nuvarande pitch
				updatePitch();

				draw();

			}, errorCallback);

			//Om det inte går att få mikrofonljudet
			function errorCallback() {
    			
    			alert('something went wrong');
			}

			//Räknar ut pitch och uppdaterar siffran i dokumentet
			//TODO: Sammanfoga med existerande variabler
			var rafID = null;
			var buflen = 2048;
			var buf = new Uint8Array( buflen );
			var pitchElem = document.getElementById( "pitch" );

			//Initerar canvas-egenskaper
			var canvas = document.querySelector('.visualizer');
			var canvasCtx = canvas.getContext("2d");
			var intendedWidth = document.querySelector('.wrapper').clientWidth;
			canvas.setAttribute('width',intendedWidth);
			WIDTH = canvas.width;
			HEIGHT = canvas.height;
			canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

			//..........All Graphics.......................
			// Make an instance of two and place it on the page
			var gamebox = document.querySelector('.game');
			var gamebox_height = document.querySelector('.game').clientHeight;


			var params = { width: intendedWidth, height: gamebox_height };
			var two = new Two(params).appendTo(gamebox);

			//HÅLET
			var hole_radius = 40;
			var hole = two.makeCircle(72, 100, hole_radius);
			hole.fill = 'grey';
			hole.stroke = 'black';
			hole.linewidth = 1;
			var hole_xPosition = intendedWidth - intendedWidth*0.1;
			var hole_yPosition = gamebox_height*0.08;
			hole.translation.set(hole_xPosition,hole_yPosition);	


			//BOLLEN
			var circle_radius = 20;
			var circle = two.makeCircle(72, 100, circle_radius);
			circle.fill = 'yellow';
			circle.stroke = 'red';
			circle.linewidth = 1;
			var xPosition = intendedWidth/2;
			var yPosition = gamebox_height - gamebox_height*0.3;
			circle.translation.set(xPosition,yPosition);

				

			var delta = new Two.Vector(0, 0);
			
			var index = [0, 0, 0, 0, 0, 0, 0, 0];
			var j = 1;

			var maxValue;

			var circle_left = xPosition-circle_radius; 
			var circle_right = xPosition+circle_radius;
			var circle_top = yPosition+circle_radius;
			var circle_bottom = yPosition-circle_radius;


			var hole_left = hole_xPosition-hole_radius; 
			var hole_right = hole_xPosition+hole_radius;
			var hole_top = hole_yPosition+hole_radius;
			var hole_bottom = hole_yPosition-hole_radius;

			
			// animationloop
			two.bind('update', function(frameCount) {

				maxValue = Math.max.apply(Math, freqDomain);
				
				for(i = 0; i < freqDomain.length; i++)
				{
					if(freqDomain[i] == maxValue)
					{
						index[j] = i;
						j++;
						if(j == 8)
							j = 0;

						break;

					}
				}
				
				//stops the ball from rollin' out of the window
				if(xPosition < (intendedWidth-20) && xPosition > 20 && index[1] != 0&& AllTheSame(index)){
					//decides the steering of the ball
					if(index[1] < 12){
						delta.x = -1;
						xPosition--;
						circle_left--;
						circle_right--;

					}
					else if(index[1] > 12){
						delta.x = +1;
						xPosition++;
						circle_left++;
						circle_right++;
					}
				}
				else
					delta.x = 0;

				
				if(circle_left > hole_left && circle_right < hole_right && circle_bottom> hole_bottom && circle_top < hole_top);
					console.log("bärs");

				circle.translation.addSelf(delta);



			}).play();


			// render everything to the screen
			two.update();
			//..............................................

			function draw() {

				requestAnimationFrame(draw);

				analyser.getByteFrequencyData(freqDomain);

				setUpVisualizer();

			}

			function AllTheSame(array) {
				var first = array[0];
					return array.every(function(element) {
    				return element === first;
				});
			}

		</script>
	</body>
</html>